

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>do_mpc package &mdash; do-mpc 4.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"], "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="API" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html">
          

          
            
            <img src="_static/dompc_var_02_white.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="mhe_example.html">Getting started: Moving Horizon Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">do_mpc package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-do_mpc.model">do_mpc.model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-do_mpc.optimizer">do_mpc.optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-do_mpc.controller">do_mpc.controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-do_mpc.estimator">do_mpc.estimator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-do_mpc.simulator">do_mpc.simulator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-do_mpc.data">do_mpc.data</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">do-mpc</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">API</a> &raquo;</li>
        
      <li>do_mpc package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/do_mpc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="do-mpc-package">
<h1>do_mpc package<a class="headerlink" href="#do-mpc-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-do_mpc.model">
<span id="do-mpc-model"></span><h2>do_mpc.model<a class="headerlink" href="#module-do_mpc.model" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="do_mpc.model.Model">
<em class="property">class </em><code class="sig-prename descclassname">do_mpc.model.</code><code class="sig-name descname">Model</code><span class="sig-paren">(</span><em class="sig-param">model_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.model.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The “<strong>do mpc</strong>” model class. This class holds the full model description and is at the core of
<a class="reference internal" href="#module-do_mpc.simulator" title="do_mpc.simulator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.simulator</span></code></a>, <a class="reference internal" href="#module-do_mpc.optimizer" title="do_mpc.optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.optimizer</span></code></a> and <a class="reference internal" href="#module-do_mpc.estimator" title="do_mpc.estimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.estimator</span></code></a>.
The <a class="reference internal" href="#module-do_mpc.model" title="do_mpc.model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model</span></code></a> class is created with setting the <cite>model_type</cite> (continuous or discrete).
A <code class="docutils literal notranslate"><span class="pre">continous</span></code> model consists of an underlying ordinary differential equation (ODE) or differential algebraic equation (DAE):</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\dot{x} = f(x,u,z,p_{tv},p)\\0 = g(x,u,z,p_{tv},p)\\y = h(x,u,z)\end{aligned}\end{align} \]</div>
<p>whereas a <code class="docutils literal notranslate"><span class="pre">discrete</span></code> model consists of a difference equation:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x_{k+1} = f(x_{k},u_{k},z_{k},p_{tv,k},p)\\0 = g(x_{k},u_{k}, z_{k},p_{tv,k},p)\\y_k = h(x_k,u_k,z_k)\end{aligned}\end{align} \]</div>
<p><strong>Configuration and setup:</strong></p>
<p>Configuring and setting up the optimizer involves the following steps:</p>
<ol class="arabic simple">
<li><p>Use <code class="xref py py-func docutils literal notranslate"><span class="pre">model.set_variable()</span></code> to introduce new variables to the model. It is important to declare the variable type (states, inputs, etc.).</p></li>
<li><p>Optionally introduce “auxiliary” expressions as functions of the previously defined variables with <code class="xref py py-func docutils literal notranslate"><span class="pre">model.set_expression()</span></code>. The expressions can be used for monitoring or be reused as constraints, the cost function etc.</p></li>
<li><p>Optionally introduce measurement equations with <code class="xref py py-func docutils literal notranslate"><span class="pre">model.set_meas()</span></code>. The syntax is identical to <code class="xref py py-func docutils literal notranslate"><span class="pre">model.set_expression()</span></code>. By default state-feedback is assumed.</p></li>
<li><p>Define the right-hand-side of the <cite>discrete</cite> or <cite>continuous</cite> model as a function of the previously defined variables with <code class="xref py py-func docutils literal notranslate"><span class="pre">model.set_rhs()</span></code>. This method must be called once for each introduced state.</p></li>
<li><p>Call <code class="xref py py-func docutils literal notranslate"><span class="pre">model.setup_model()</span></code> to finalize the <code class="docutils literal notranslate"><span class="pre">model</span></code>. No further changes are possible afterwards.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model_type</strong> – Set if the model is <code class="docutils literal notranslate"><span class="pre">discrete</span></code> or <code class="docutils literal notranslate"><span class="pre">continuous</span></code>.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>assertion</strong> – model_type must be string</p></li>
<li><p><strong>assertion</strong> – model_type must be either discrete or continuous</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="do_mpc.model.Model.set_variable">
<code class="sig-name descname">set_variable</code><span class="sig-paren">(</span><em class="sig-param">var_type</em>, <em class="sig-param">var_name</em>, <em class="sig-param">shape=(1</em>, <em class="sig-param">1)</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.model.Model.set_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduce new variables to the model class. Define variable type, name and shape (optional).</p>
<p><strong>Example:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># States struct (optimization variables):</span>
<span class="n">C_a</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_x&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;C_a&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">T_K</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_x&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;T_K&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Input struct (optimization variables):</span>
<span class="n">Q_dot</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_u&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Q_dot&#39;</span><span class="p">)</span>

<span class="c1"># Fixed parameters:</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">var_type</span></code> allows a shorthand notation e.g. <code class="docutils literal notranslate"><span class="pre">_x</span></code> which is equivalent to <code class="docutils literal notranslate"><span class="pre">states</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var_type</strong> (<em>string</em>) – <p>Declare the type of the variable. The following types are valid (long or short name is possible):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 41%" />
<col style="width: 17%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Long name</p></th>
<th class="head"><p>short name</p></th>
<th class="head"><p>Remark</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">states</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">_x</span></code></p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">inputs</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">_u</span></code></p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">algebraic</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">_z</span></code></p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">parameter</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">_p</span></code></p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">timevarying_parameter</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">_tvp</span></code></p></td>
<td><p>Optional</p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>var_name</strong> – Set a user-defined name for the parameter. The names are reused throughout do_mpc.</p></li>
<li><p><strong>shape</strong> (<em>int</em><em> or </em><em>tuple of length 2.</em>) – Shape of the current variable (optional), defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>assertion</strong> – var_type must be string</p></li>
<li><p><strong>assertion</strong> – var_name must be string</p></li>
<li><p><strong>assertion</strong> – shape must be tuple or int</p></li>
<li><p><strong>assertion</strong> – Cannot call after <code class="xref py py-func docutils literal notranslate"><span class="pre">model.setup_model()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns the newly created symbolic variable. Variables can be used to create aux expressions.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>casadi.SX</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.model.Model.set_expression">
<code class="sig-name descname">set_expression</code><span class="sig-paren">(</span><em class="sig-param">expr_name</em>, <em class="sig-param">expr</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.model.Model.set_expression" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduce new expression to the model class. Expressions are not required but can be used
to extract further information from the model. They can also be use for the objective function or constraints.
Expressions must be formulated with respect to <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr_name</strong> (<em>string</em>) – Arbitrary name for the given expression. Names are used for key word indexing.</p></li>
<li><p><strong>expr</strong> (<em>CasADi SX</em><em> or </em><em>MX</em>) – CasADi SX or MX function depending on <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>assertion</strong> – expr_name must be str</p></li>
<li><p><strong>assertion</strong> – expr must be a casadi SX or MX type</p></li>
<li><p><strong>assertion</strong> – Cannot call after .setup_model.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns the newly created expression. Expression can be used e.g. for the RHS.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>casadi.SX</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.model.Model.set_meas">
<code class="sig-name descname">set_meas</code><span class="sig-paren">(</span><em class="sig-param">meas_name</em>, <em class="sig-param">expr</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.model.Model.set_meas" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduce new measurable output to the model class. By default, the model assumes state-feedback (all states are measured outputs).
Expressions must be formulated with respect to <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr_name</strong> (<em>string</em>) – Arbitrary name for the given expression. Names are used for key word indexing.</p></li>
<li><p><strong>expr</strong> (<em>CasADi SX</em><em> or </em><em>MX</em>) – CasADi SX or MX function depending on <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>assertion</strong> – expr_name must be str</p></li>
<li><p><strong>assertion</strong> – expr must be a casadi SX or MX type</p></li>
<li><p><strong>assertion</strong> – Cannot call after .setup_model.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns the newly created measurement expression.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>casadi.SX</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.model.Model.set_rhs">
<code class="sig-name descname">set_rhs</code><span class="sig-paren">(</span><em class="sig-param">var_name</em>, <em class="sig-param">expr</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.model.Model.set_rhs" title="Permalink to this definition">¶</a></dt>
<dd><p>Formulate the right hand side (rhs) of the ODE. Each defined state variable must have a respective equation (of matching dimension)
for the rhs. Match the rhs with the state by choosing the corresponding names.
RHS must be formulated with respect to <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code>.</p>
<p><strong>Example</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tank_level</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="s1">&#39;states&#39;</span><span class="p">,</span> <span class="s1">&#39;tank_level&#39;</span><span class="p">)</span>
<span class="n">tank_temp</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="s1">&#39;states&#39;</span><span class="p">,</span> <span class="s1">&#39;tank_temp&#39;</span><span class="p">)</span>

<span class="n">tank_level_next</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">tank_level</span>
<span class="n">tank_temp_next</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">model</span><span class="o">.</span><span class="n">set_rhs</span><span class="p">(</span><span class="s1">&#39;tank_level&#39;</span><span class="p">,</span> <span class="n">tank_level_next</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">set_rhs</span><span class="p">(</span><span class="s1">&#39;tank_temp&#39;</span><span class="p">,</span> <span class="n">tank_temp_next</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var_name</strong> (<em>string</em>) – Name of any of the previously defined states with: model.set_variable(‘states’, [NAME])</p></li>
<li><p><strong>expr</strong> (<em>CasADi SX</em><em> or </em><em>MX</em>) – CasADi SX or MX function depending on <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>assertion</strong> – var_name must be str</p></li>
<li><p><strong>assertion</strong> – expr must be a casadi SX or MX type</p></li>
<li><p><strong>assertion</strong> – var_name must refer to the previously defined states</p></li>
<li><p><strong>assertion</strong> – Cannot call after .setup_model.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.model.Model.get_variables">
<code class="sig-name descname">get_variables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.model.Model.get_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to retrieve the variables of the model. This method is convenient when creating the model in a different file
than the, e.g. the <a class="reference internal" href="#module-do_mpc.optimizer" title="do_mpc.optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.optimizer</span></code></a>. Returns the variables as a list with the following order:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_x</span></code> (states)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_u</span></code> (inputs)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_z</span></code> (algebraic variables)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_tvp</span></code> (time varying parameters)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_p</span></code> (uncertain parameters)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_aux</span></code> (auxiliary expressions)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_y</span></code> (measurements, measured)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_y_expression</span></code> (measurements, calculated)</p></li>
</ul>
<p>The method cannot be called prior to <code class="xref py py-func docutils literal notranslate"><span class="pre">model.setup()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>assertion</strong> – Model was not setup. Finish model creation by calling model.setup_model().</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of model variables (<code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code>, <code class="docutils literal notranslate"><span class="pre">_aux</span></code>)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.model.Model.setup_model">
<code class="sig-name descname">setup_model</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.model.Model.setup_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup method must be called to finalize the modelling process.
All required model variables <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code> must be declared.
The right hand side expression for <code class="docutils literal notranslate"><span class="pre">_x</span></code> must have been set with <code class="xref py py-func docutils literal notranslate"><span class="pre">model.set_rhs()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>assertion</strong> – Definition of right hand side (rhs) is incomplete</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-do_mpc.optimizer">
<span id="do-mpc-optimizer"></span><h2>do_mpc.optimizer<a class="headerlink" href="#module-do_mpc.optimizer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="do_mpc.optimizer.Optimizer">
<em class="property">class </em><code class="sig-prename descclassname">do_mpc.optimizer.</code><code class="sig-name descname">Optimizer</code><a class="headerlink" href="#do_mpc.optimizer.Optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The base clase for the optimization based state estimation (MHE) and predictive controller (MPC).
This class establishes the jointly used attributes, methods and properties.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Optimizer</span></code> base class can not be used independently.</p>
<dl class="attribute">
<dt id="do_mpc.optimizer.Optimizer.bounds">
<code class="sig-name descname">bounds</code><a class="headerlink" href="#do_mpc.optimizer.Optimizer.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Queries and sets the bounds of the optimization variables for the optimizer.
The <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.bounds()</span></code> method is an indexed property, meaning
getting and setting this property requires an index and calls this function.
The power index (elements are seperated by comas) must contain atleast the following elements:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bound_type</span></code>: Valid options are <code class="docutils literal notranslate"><span class="pre">lower</span></code> and <code class="docutils literal notranslate"><span class="pre">upper</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">var_type</span></code>: Valid options are <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code> and <code class="docutils literal notranslate"><span class="pre">_z</span></code> (and <code class="docutils literal notranslate"><span class="pre">_p_est</span></code> for MHE).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">var_name</span></code>: Variable names that were previously defined in the <a class="reference internal" href="#module-do_mpc.model" title="do_mpc.model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model</span></code></a>.</p></li>
</ol>
<p>Further indices are possible (but not neccessary) when the referenced variable is a vector or matrix.</p>
<p><strong>Example</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set with:</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span><span class="s1">&#39;_x&#39;</span><span class="p">,</span> <span class="s1">&#39;phi_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">,</span><span class="s1">&#39;_x&#39;</span><span class="p">,</span> <span class="s1">&#39;phi_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="c1"># Query with:</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span><span class="s1">&#39;_x&#39;</span><span class="p">,</span> <span class="s1">&#39;phi_1&#39;</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind</strong> (<em>tuple</em>) – power index with elements mentioned above.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="do_mpc.optimizer.Optimizer.scaling">
<code class="sig-name descname">scaling</code><a class="headerlink" href="#do_mpc.optimizer.Optimizer.scaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Queries and sets the scaling of the optimization variables for the optimizer.
The <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.scaling()</span></code> method is an indexed property, meaning
getting and setting this property requires an index and calls this function.
The power index (elements are seperated by comas) must contain atleast the following elements:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">var_type</span></code>: Valid options are <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code> and <code class="docutils literal notranslate"><span class="pre">_z</span></code> (and <code class="docutils literal notranslate"><span class="pre">_p_est</span></code> for MHE).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">var_name</span></code>: Variable names that were previously defined in the <a class="reference internal" href="#module-do_mpc.model" title="do_mpc.model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model</span></code></a>.</p></li>
</ol>
<p>Further indices are possible (but not neccessary) when the referenced variable is a vector or matrix.</p>
<p><strong>Example</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set with:</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">scaling</span><span class="p">[</span><span class="s1">&#39;_x&#39;</span><span class="p">,</span> <span class="s1">&#39;phi_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">scaling</span><span class="p">[</span><span class="s1">&#39;_x&#39;</span><span class="p">,</span> <span class="s1">&#39;phi_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Query with:</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">scaling</span><span class="p">[</span><span class="s1">&#39;_x&#39;</span><span class="p">,</span> <span class="s1">&#39;phi_1&#39;</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind</strong> (<em>tuple</em>) – power index with elements mentioned above.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.optimizer.Optimizer.set_initial_state">
<code class="sig-name descname">set_initial_state</code><span class="sig-paren">(</span><em class="sig-param">x0</em>, <em class="sig-param">p_est0=None</em>, <em class="sig-param">reset_history=False</em>, <em class="sig-param">set_intial_guess=True</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.optimizer.Optimizer.set_initial_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the intial state of the optimizer.
Optionally resets the history. The history is empty upon creation of the optimizer.</p>
<p>Optionally update the initial guess. The initial guess is first created with the <code class="docutils literal notranslate"><span class="pre">.setup()</span></code> method (MHE/MPC)
and uses the class attributes <code class="docutils literal notranslate"><span class="pre">_x0</span></code>, <code class="docutils literal notranslate"><span class="pre">_u0</span></code>, <code class="docutils literal notranslate"><span class="pre">_z0</span></code> for all time instances, collocation points (if applicable)
and scenarios (if applicable). If these values were net explicitly set by the user, they default to all zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>numpy array</em>) – Initial state</p></li>
<li><p><strong>reset_history</strong> (<em>bool</em><em> (</em><em>,</em><em>optional</em><em>)</em>) – Resets the history of the optimizer, defaults to False</p></li>
<li><p><strong>set_intial_guess</strong> (<em>bool</em><em> (</em><em>,</em><em>optional</em><em>)</em>) – Setting the initial state also updates the intial guess for the optimizer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.optimizer.Optimizer.reset_history">
<code class="sig-name descname">reset_history</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.optimizer.Optimizer.reset_history" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the history of the optimizer</p>
</dd></dl>

<dl class="method">
<dt id="do_mpc.optimizer.Optimizer.set_nl_cons">
<code class="sig-name descname">set_nl_cons</code><span class="sig-paren">(</span><em class="sig-param">expr_name</em>, <em class="sig-param">expr</em>, <em class="sig-param">lb=-inf</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.optimizer.Optimizer.set_nl_cons" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduce new constraint to the class. Further constraints are optional.
Expressions must be formulated with respect to <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr_name</strong> (<em>string</em>) – Arbitrary name for the given expression. Names are used for key word indexing.</p></li>
<li><p><strong>expr</strong> (<em>CasADi SX</em><em> or </em><em>MX</em>) – CasADi SX or MX function depending on <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>assertion</strong> – expr_name must be str</p></li>
<li><p><strong>assertion</strong> – expr must be a casadi SX or MX type</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Returns the newly created expression. Expression can be used e.g. for the RHS.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>casadi.SX</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.optimizer.Optimizer.get_tvp_template">
<code class="sig-name descname">get_tvp_template</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.optimizer.Optimizer.get_tvp_template" title="Permalink to this definition">¶</a></dt>
<dd><p>The method returns a structured object with n_horizon elements, and a set of time varying parameters (as defined in model)
for each of these instances. The structure is initialized with all zeros. Use this object to define values of the time varying parameters.</p>
<p>This structure (with numerical values) should be used as the output of the <code class="docutils literal notranslate"><span class="pre">tvp_fun</span></code> function which is set to the class with <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.set_tvp_fun()</span></code>.
Use the combination of <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.get_tvp_template()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.set_tvp_fun()</span></code>.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in model definition:</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_tvp&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_tvp&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;beta&#39;</span><span class="p">)</span>

<span class="o">...</span>
<span class="c1"># in optimizer configuration:</span>
<span class="n">tvp_temp_1</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">get_tvp_template</span><span class="p">()</span>
<span class="n">tvp_temp_1</span><span class="p">[</span><span class="s1">&#39;_tvp&#39;</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="n">tvp_temp_2</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">get_tvp_template</span><span class="p">()</span>
<span class="n">tvp_temp_2</span><span class="p">[</span><span class="s1">&#39;_tvp&#39;</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">tvp_fun</span><span class="p">(</span><span class="n">t_now</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t_now</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tvp_temp_1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tvp_temp_2</span>

<span class="n">optimizer</span><span class="o">.</span><span class="n">set_tvp_fun</span><span class="p">(</span><span class="n">tvp_fun</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.optimizer.Optimizer.set_tvp_fun">
<code class="sig-name descname">set_tvp_fun</code><span class="sig-paren">(</span><em class="sig-param">tvp_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.optimizer.Optimizer.set_tvp_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the tvp_fun which is called at each optimization step to get the current prediction of the time-varying parameters.
The supplied function must be callable with the current time as the only input. Furthermore, the function must return
a CasADi structured object which is based on the horizon and on the model definition. The structure can be obtained with
<code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.get_tvp_template()</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in model definition:</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_tvp&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_tvp&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;beta&#39;</span><span class="p">)</span>

<span class="o">...</span>
<span class="c1"># in optimizer configuration:</span>
<span class="n">tvp_temp_1</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">get_tvp_template</span><span class="p">()</span>
<span class="n">tvp_temp_1</span><span class="p">[</span><span class="s1">&#39;_tvp&#39;</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

<span class="n">tvp_temp_2</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">get_tvp_template</span><span class="p">()</span>
<span class="n">tvp_temp_2</span><span class="p">[</span><span class="s1">&#39;_tvp&#39;</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">tvp_fun</span><span class="p">(</span><span class="n">t_now</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t_now</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tvp_temp_1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tvp_temp_2</span>

<span class="n">optimizer</span><span class="o">.</span><span class="n">set_tvp_fun</span><span class="p">(</span><span class="n">tvp_fun</span><span class="p">)</span>
</pre></div>
</div>
<p>The method <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.set_tvp_fun()</span></code>. must be called prior to setup IF time-varying parameters are defined in the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tvp_fun</strong> (<em>function</em>) – Function that returns the predicted tvp values at each timestep. Must have single input (float) and return a structure3.DMStruct (obtained with .get_tvp_template())</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.optimizer.Optimizer.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.optimizer.Optimizer.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the optmization problem. The current time-step is defined by the parameters in the
self.opt_p_num CasADi structured Data. These include the initial condition, the parameters, the time-varying paramters and the previous u.
Typically, self.opt_p_num is prepared for the current iteration in the <code class="docutils literal notranslate"><span class="pre">.make_step()</span></code> (in MHE/MPC) method.
It is, however, valid and possible to directly set paramters in self.opt_p_num before calling .solve().</p>
<p>Solve updates the opt_x_num, and lam_g_num attributes of the class. In resetting, opt_x_num to the current solution, the method implicitly
enables warmstarting the optimizer for the next iteration, since this vector is always used as the initial guess.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>asssertion</strong> – optimizer was not setup yet.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-do_mpc.controller">
<span id="do-mpc-controller"></span><h2>do_mpc.controller<a class="headerlink" href="#module-do_mpc.controller" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="do_mpc.controller.MPC">
<em class="property">class </em><code class="sig-prename descclassname">do_mpc.controller.</code><code class="sig-name descname">MPC</code><span class="sig-paren">(</span><em class="sig-param">model</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#do_mpc.optimizer.Optimizer" title="do_mpc.optimizer.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.optimizer.Optimizer</span></code></a></p>
<p>THE MPC controller extends the optimizer base class (which is also used for the MHE estimator).
Use this class to configure and run the MPC controller based on a previously configured <a class="reference internal" href="#module-do_mpc.model" title="do_mpc.model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model</span></code></a> instance.</p>
<p><strong>Configuration and setup:</strong></p>
<p>Configuring and setting up the MPC controller involves the following steps:</p>
<ol class="arabic simple">
<li><p>Use <a class="reference internal" href="#do_mpc.controller.MPC.set_param" title="do_mpc.controller.MPC.set_param"><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.set_param()</span></code></a> to configure the <a class="reference internal" href="#do_mpc.controller.MPC" title="do_mpc.controller.MPC"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPC</span></code></a>. See docstring for details.</p></li>
<li><p>Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">do_mpc.model.get_variables()</span></code> to obtain the variables defined in <a class="reference internal" href="#module-do_mpc.model" title="do_mpc.model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model</span></code></a> and express the objective of the optimization problem in terms of these variables.</p></li>
<li><p>Set the objective of the control problem with <a class="reference internal" href="#do_mpc.controller.MPC.set_objective" title="do_mpc.controller.MPC.set_objective"><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.set_objective()</span></code></a>.</p></li>
<li><p>Use <code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.get_rterm()</span></code> to obtain the structure of weighting parameters to penalize changes in the input and set appropriate values.  See docstring for details.</p></li>
<li><p>Set upper and lower bounds.</p></li>
<li><p>Optionally, set further (non-linear) constraints with <code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.set_nl_cons()</span></code>. See docstring for details.</p></li>
<li><p>Use the low-level API (<a class="reference internal" href="#do_mpc.controller.MPC.get_p_template" title="do_mpc.controller.MPC.get_p_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.get_p_template()</span></code></a> and <a class="reference internal" href="#do_mpc.controller.MPC.set_p_fun" title="do_mpc.controller.MPC.set_p_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.set_p_fun()</span></code></a>) or high level API (<a class="reference internal" href="#do_mpc.controller.MPC.set_uncertainty_values" title="do_mpc.controller.MPC.set_uncertainty_values"><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.set_uncertainty_values()</span></code></a>) to create scenarios for robust MPC. See docstrings for details.</p></li>
<li><p>Finally, call <a class="reference internal" href="#do_mpc.controller.MPC.setup" title="do_mpc.controller.MPC.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.setup()</span></code></a>.</p></li>
</ol>
<dl class="method">
<dt id="do_mpc.controller.MPC.set_param">
<code class="sig-name descname">set_param</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC.set_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to set the parameters of the <a class="reference internal" href="#do_mpc.controller.MPC" title="do_mpc.controller.MPC"><code class="xref py py-class docutils literal notranslate"><span class="pre">MPC</span></code></a> class. Parameters must be passed as pairs of valid keywords and respective argument.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mpc</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="n">n_horizon</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible and convenient to pass a dictionary with multiple parameters simultaneously as shown in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">setup_mpc</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;n_horizon&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="s1">&#39;t_step&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">mpc</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="o">**</span><span class="n">setup_mpc</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#do_mpc.controller.MPC.set_param" title="do_mpc.controller.MPC.set_param"><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.set_param()</span></code></a> can be called multiple times. Previously passed arguments are overwritten by successive calls.</p>
</div>
<p>The following parameters are available:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_horizon</strong> (<em>int</em>) – Prediction horizon of the optimal control problem. Parameter must be set by user.</p></li>
<li><p><strong>n_robust</strong> (<em>int</em><em> , </em><em>optional</em>) – Robust horizon for robust scenario-tree MPC, defaults to <code class="docutils literal notranslate"><span class="pre">0</span></code>. Optimization problem grows exponentially with <code class="docutils literal notranslate"><span class="pre">n_robust</span></code>.</p></li>
<li><p><strong>open_loop</strong> (<em>bool</em><em> , </em><em>optional</em>) – Setting for scenario-tree MPC: If the parameter is <code class="docutils literal notranslate"><span class="pre">False</span></code>, for each timestep <strong>AND</strong> scenario an individual control input is computed. If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the same control input is used for each scenario. Defaults to False.</p></li>
<li><p><strong>t_step</strong> (<em>float</em>) – Timestep of the mpc.</p></li>
<li><p><strong>state_discretization</strong> (<em>str</em>) – Choose the state discretization for continuous models. Currently only <code class="docutils literal notranslate"><span class="pre">'collocation'</span></code> is available. Defaults to <code class="docutils literal notranslate"><span class="pre">'collocation'</span></code>.</p></li>
<li><p><strong>collocation_type</strong> (<em>str</em>) – Choose the collocation type for continuous models with collocation as state discretization. Currently only <code class="docutils literal notranslate"><span class="pre">'radau'</span></code> is available. Defaults to <code class="docutils literal notranslate"><span class="pre">'radau'</span></code>.</p></li>
<li><p><strong>collocation_deg</strong> (<em>int</em>) – Choose the collocation degree for continuous models with collocation as state discretization. Defaults to <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p></li>
<li><p><strong>collocation_ni</strong> (<em>int</em>) – Choose the collocation ni for continuous models with collocation as state discretization. Defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
<li><p><strong>store_full_solution</strong> (<em>bool</em>) – Choose whether to store the full solution of the optimization problem. This is required for animating the predictions in post processing. However, it drastically increases the required storage. Defaults to False.</p></li>
<li><p><strong>store_lagr_multiplier</strong> (<em>bool</em>) – Choose whether to store the lagrange multipliers of the optimization problem. Increases the required storage. Defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>store_solver_stats</strong> (<em>dict</em>) – Choose which solver statistics to store. Must be a list of valid statistics. Defaults to <code class="docutils literal notranslate"><span class="pre">['success','t_wall_S','t_wall_S']</span></code>.</p></li>
<li><p><strong>nlpsol_opts</strong> – Dictionary with options for the CasADi solver call <code class="docutils literal notranslate"><span class="pre">nlpsol</span></code> with plugin <code class="docutils literal notranslate"><span class="pre">ipopt</span></code>. All options are listed <a class="reference external" href="http://casadi.sourceforge.net/api/internal/d4/d89/group__nlpsol.html">here</a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We highly suggest to change the linear solver for IPOPT from <cite>mumps</cite> to <cite>MA27</cite>. In many cases this will drastically boost the speed of <strong>do mpc</strong>. Change the linear solver with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="n">nlpsol_opts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ipopt.linear_solver&#39;</span><span class="p">:</span> <span class="s1">&#39;MA27&#39;</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To surpress the output of IPOPT, please use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">surpress_ipopt</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ipopt.print_level&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ipopt.sb&#39;</span><span class="p">:</span> <span class="s1">&#39;yes&#39;</span><span class="p">,</span> <span class="s1">&#39;print_time&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="n">nlpsol_opts</span> <span class="o">=</span> <span class="n">surpress_ipopt</span><span class="p">)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="do_mpc.controller.MPC.set_objective">
<code class="sig-name descname">set_objective</code><span class="sig-paren">(</span><em class="sig-param">mterm=None</em>, <em class="sig-param">lterm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC.set_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the objective of the optimal control problem (OCP). We introduce the following notation:</p>
<div class="math notranslate nohighlight">
\[\min_{x,u,z}\quad \sum_{k=0}^{n-1} ( l(x_k,u_k,z_k,p) + \Delta u_k^T R \Delta u_k ) + m(x_n)\]</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.set_objective()</span></code> is used to set the <span class="math notranslate nohighlight">\(l(x_k,u_k,z_k,p)\)</span> (<code class="docutils literal notranslate"><span class="pre">lterm</span></code>) and <span class="math notranslate nohighlight">\(m(x_N)\)</span> (<code class="docutils literal notranslate"><span class="pre">lterm</span></code>), where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the prediction horizon.
Please see <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.set_rterm()</span></code> for the <code class="docutils literal notranslate"><span class="pre">rterm</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lterm</strong> (<em>CasADi SX</em><em> or </em><em>MX</em>) – Stage cost - <strong>scalar</strong> symbolic expression with respect to <code class="docutils literal notranslate"><span class="pre">_x</span></code>, <code class="docutils literal notranslate"><span class="pre">_u</span></code>, <code class="docutils literal notranslate"><span class="pre">_z</span></code>, <code class="docutils literal notranslate"><span class="pre">_tvp</span></code>, <code class="docutils literal notranslate"><span class="pre">_p</span></code></p></li>
<li><p><strong>mterm</strong> (<em>CasADi SX</em><em> or </em><em>MX</em>) – Terminal cost - <strong>scalar</strong> symbolic expression with respect to <code class="docutils literal notranslate"><span class="pre">_x</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>assertion</strong> – mterm must have shape=(1,1) (scalar expression)</p></li>
<li><p><strong>assertion</strong> – lterm must have shape=(1,1) (scalar expression)</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.controller.MPC.set_rterm">
<code class="sig-name descname">set_rterm</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC.set_rterm" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the penality factor for the inputs. Call this function with keyword argument refering to the input names in
<code class="xref py py-class docutils literal notranslate"><span class="pre">model</span></code> and the penalty factor as the respective value.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in model definition:</span>
<span class="n">Q_heat</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_u&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;Q_heat&#39;</span><span class="p">)</span>
<span class="n">F_flow</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_u&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;F_flow&#39;</span><span class="p">)</span>

<span class="o">...</span>
<span class="c1"># in optimizer configuration:</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">set_rterm</span><span class="p">(</span><span class="n">Q_heat</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">set_rterm</span><span class="p">(</span><span class="n">F_flow</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
<span class="c1"># or alternatively:</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">set_rterm</span><span class="p">(</span><span class="n">Q_heat</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">F_flow</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="do_mpc.controller.MPC.get_p_template">
<code class="sig-name descname">get_p_template</code><span class="sig-paren">(</span><em class="sig-param">n_combinations</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC.get_p_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Low level API method to set user defined scenarios for robust MPC but defining an arbitrary number
of combinations for the parameters defined in the model. The method returns a structured object which is
initialized with all zeros. Use this object to define value of the parameters for an arbitrary number of scenarios (defined by n_scenarios).</p>
<p>This structure (with numerical values) should be used as the output of the p_fun function which is set to the class with .set_p_fun (see doc string).</p>
<p>Use the combination of .get_p_template() and .set_p_template() as a more adaptable alternative to .set_uncertainty_values().</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in model definition:</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;beta&#39;</span><span class="p">)</span>

<span class="o">...</span>
<span class="c1"># in optimizer configuration:</span>
<span class="n">n_combinations</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">p_template</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">get_p_template</span><span class="p">(</span><span class="n">n_combinations</span><span class="p">)</span>
<span class="n">p_template</span><span class="p">[</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">p_template</span><span class="p">[</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>
<span class="n">p_template</span><span class="p">[</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">p_fun</span><span class="p">(</span><span class="n">t_now</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p_template</span>

<span class="n">optimizer</span><span class="o">.</span><span class="n">set_p_fun</span><span class="p">(</span><span class="n">p_fun</span><span class="p">)</span>
</pre></div>
</div>
<p>Note the nominal case is now:
alpha = 1
beta = 1
which is determined by the order in the arrays above (first element is nominal).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_combinations</strong> (<em>int</em>) – Define the number of combinations for the uncertain parameters for robust MPC.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.controller.MPC.set_p_fun">
<code class="sig-name descname">set_p_fun</code><span class="sig-paren">(</span><em class="sig-param">p_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC.set_p_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Low level API method to set user defined scenarios for robust MPC but defining an arbitrary number
of combinations for the parameters defined in the model. The method takes as input a function, which MUST
return a structured object, based on the defined parameters and the number of combinations.
The defined function has time as a single input.</p>
<p>Obtain this structured object first, by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.get_p_template()</span></code>.</p>
<p>Use the combination of <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.get_p_template()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.set_p_fun()</span></code> as a more adaptable alternative to <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.set_uncertainty_values()</span></code>.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in model definition:</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;beta&#39;</span><span class="p">)</span>

<span class="o">...</span>
<span class="c1"># in optimizer configuration:</span>
<span class="n">n_combinations</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">p_template</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">get_p_template</span><span class="p">(</span><span class="n">n_combinations</span><span class="p">)</span>
<span class="n">p_template</span><span class="p">[</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">p_template</span><span class="p">[</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>
<span class="n">p_template</span><span class="p">[</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">p_fun</span><span class="p">(</span><span class="n">t_now</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p_template</span>

<span class="n">optimizer</span><span class="o">.</span><span class="n">set_p_fun</span><span class="p">(</span><span class="n">p_fun</span><span class="p">)</span>
</pre></div>
</div>
<p>Note the nominal case is now:
alpha = 1
beta = 1
which is determined by the order in the arrays above (first element is nominal).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p_fun</strong> – Function which returns a structure with numerical values. Must be the same structure as obtained from <code class="xref py py-func docutils literal notranslate"><span class="pre">optimizer.get_p_template()</span></code>.</p>
</dd>
</dl>
<p>Function must have a single input (time).
:type p_fun: function</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.controller.MPC.set_uncertainty_values">
<code class="sig-name descname">set_uncertainty_values</code><span class="sig-paren">(</span><em class="sig-param">uncertainty_values</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC.set_uncertainty_values" title="Permalink to this definition">¶</a></dt>
<dd><p>High-level API method to conveniently set all possible scenarios for multistage MPC, given a list of uncertainty values.
This list must have the same number of elements as uncertain parameters in the model definition. The first element is the nominal case.
Each list element can be an array or list of possible values for the respective parameter.
Note that the order of elements determine the assignment.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># in model definition:</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;alpha&#39;</span><span class="p">)</span>
<span class="n">beta</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="n">var_type</span><span class="o">=</span><span class="s1">&#39;_p&#39;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s1">&#39;beta&#39;</span><span class="p">)</span>
<span class="o">...</span>
<span class="c1"># in optimizer configuration:</span>
<span class="n">alpha_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">])</span>
<span class="n">beta_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">])</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">set_uncertainty_values</span><span class="p">([</span><span class="n">alpha_var</span><span class="p">,</span> <span class="n">beta_var</span><span class="p">])</span>
</pre></div>
</div>
<p>Note the nominal case is now:
alpha = 1
beta = 1
which is determined by the order in the arrays above (first element is nominal).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>uncertainty_values</strong> (<em>list</em>) – List of lists / numpy arrays with the same number of elements as number of parameters in model.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>asssertion</strong> – uncertainty values must be of type list</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.controller.MPC.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>The setup method finalizes the optimizer creation. After this call, the py:func:<cite>.solve()</cite> method is applicable.
The method wraps the following calls:</p>
<ul class="simple">
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.check_validity()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC._setup_mpc_optim_problem()</span></code></p></li>
<li><p><a class="reference internal" href="#do_mpc.controller.MPC.set_initial_guess" title="do_mpc.controller.MPC.set_initial_guess"><code class="xref py py-func docutils literal notranslate"><span class="pre">MPC.set_initial_guess()</span></code></a></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">do_mpc.optimizer.prepare_data()</span></code></p></li>
</ul>
<p>and sets the setup flag = True.</p>
</dd></dl>

<dl class="method">
<dt id="do_mpc.controller.MPC.set_initial_guess">
<code class="sig-name descname">set_initial_guess</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC.set_initial_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the current class attributes <code class="docutils literal notranslate"><span class="pre">_x0</span></code>, <code class="docutils literal notranslate"><span class="pre">_z0</span></code> and <code class="docutils literal notranslate"><span class="pre">_u0</span></code> to create an initial guess for the optimizer.
The initial guess is simply the initial values for all instances of x, u and z. The method is automatically
evoked when calling the .setup() method.
However, if no initial values for x, u and z were supplied during setup, these default to zero.</p>
</dd></dl>

<dl class="method">
<dt id="do_mpc.controller.MPC.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">x0</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.controller.MPC.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Main method of the class during runtime. This method is called at each timestep
and returns the control input for the current initial state <code class="docutils literal notranslate"><span class="pre">x0</span></code>.</p>
<p>The method prepares the MHE by setting the current parameters, calls <code class="xref py py-func docutils literal notranslate"><span class="pre">do_mpc.optimizer.solve()</span></code>
and updates the <a class="reference internal" href="#do_mpc.data.Data" title="do_mpc.data.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.data.Data</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x0</strong> (<em>numpy.ndarray</em>) – Current state of the system.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>u0</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-do_mpc.estimator">
<span id="do-mpc-estimator"></span><h2>do_mpc.estimator<a class="headerlink" href="#module-do_mpc.estimator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="do_mpc.estimator.Estimator">
<em class="property">class </em><code class="sig-prename descclassname">do_mpc.estimator.</code><code class="sig-name descname">Estimator</code><span class="sig-paren">(</span><em class="sig-param">model</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.Estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The Estimator base class. Used for <a class="reference internal" href="#do_mpc.estimator.StateFeedback" title="do_mpc.estimator.StateFeedback"><code class="xref py py-class docutils literal notranslate"><span class="pre">StateFeedback</span></code></a>, <a class="reference internal" href="#do_mpc.estimator.EKF" title="do_mpc.estimator.EKF"><code class="xref py py-class docutils literal notranslate"><span class="pre">EKF</span></code></a> and <a class="reference internal" href="#do_mpc.estimator.MHE" title="do_mpc.estimator.MHE"><code class="xref py py-class docutils literal notranslate"><span class="pre">MHE</span></code></a>.
This class cannot be used independently.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods <a class="reference internal" href="#do_mpc.estimator.Estimator.set_initial_state" title="do_mpc.estimator.Estimator.set_initial_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">Estimator.set_initial_state()</span></code></a> and <a class="reference internal" href="#do_mpc.estimator.Estimator.reset_history" title="do_mpc.estimator.Estimator.reset_history"><code class="xref py py-func docutils literal notranslate"><span class="pre">Estimator.reset_history()</span></code></a>
are overwritten when using the <a class="reference internal" href="#do_mpc.estimator.MHE" title="do_mpc.estimator.MHE"><code class="xref py py-class docutils literal notranslate"><span class="pre">MHE</span></code></a> by the methods defined in <a class="reference internal" href="#do_mpc.optimizer.Optimizer" title="do_mpc.optimizer.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.optimizer.Optimizer</span></code></a>.</p>
</div>
<dl class="method">
<dt id="do_mpc.estimator.Estimator.set_initial_state">
<code class="sig-name descname">set_initial_state</code><span class="sig-paren">(</span><em class="sig-param">x0</em>, <em class="sig-param">reset_history=False</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.Estimator.set_initial_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the intial state of the estimator.
Optionally resets the history. The history is empty upon creation of the estimator.
This method is overwritten for the <a class="reference internal" href="#do_mpc.estimator.MHE" title="do_mpc.estimator.MHE"><code class="xref py py-class docutils literal notranslate"><span class="pre">MHE</span></code></a> from <a class="reference internal" href="#do_mpc.optimizer.Optimizer" title="do_mpc.optimizer.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.optimizer.Optimizer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>numpy array</em>) – Initial state</p></li>
<li><p><strong>reset_history</strong> (<em>bool</em><em> (</em><em>,</em><em>optional</em><em>)</em>) – Resets the history of the estimator, defaults to False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.estimator.Estimator.reset_history">
<code class="sig-name descname">reset_history</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.Estimator.reset_history" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the history of the estimator</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="do_mpc.estimator.StateFeedback">
<em class="property">class </em><code class="sig-prename descclassname">do_mpc.estimator.</code><code class="sig-name descname">StateFeedback</code><span class="sig-paren">(</span><em class="sig-param">model</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.StateFeedback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#do_mpc.estimator.Estimator" title="do_mpc.estimator.Estimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.estimator.Estimator</span></code></a></p>
<p>Simple state-feedback “estimator”.
The main method <a class="reference internal" href="#do_mpc.estimator.StateFeedback.make_step" title="do_mpc.estimator.StateFeedback.make_step"><code class="xref py py-func docutils literal notranslate"><span class="pre">StateFeedback.make_step()</span></code></a> simply returns the input.
Why do you even bother to use this class?</p>
<dl class="method">
<dt id="do_mpc.estimator.StateFeedback.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">y0</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.StateFeedback.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the measurement <code class="docutils literal notranslate"><span class="pre">y0</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="do_mpc.estimator.EKF">
<em class="property">class </em><code class="sig-prename descclassname">do_mpc.estimator.</code><code class="sig-name descname">EKF</code><span class="sig-paren">(</span><em class="sig-param">model</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.EKF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#do_mpc.estimator.Estimator" title="do_mpc.estimator.Estimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.estimator.Estimator</span></code></a></p>
<p>Extended Kalman Filter. Setup this class and use <a class="reference internal" href="#do_mpc.estimator.EKF.make_step" title="do_mpc.estimator.EKF.make_step"><code class="xref py py-func docutils literal notranslate"><span class="pre">EKF.make_step()</span></code></a>
during runtime to obtain the currently estimated states given the measurements <code class="docutils literal notranslate"><span class="pre">y0</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Not currently implemented.</p>
</div>
<dl class="method">
<dt id="do_mpc.estimator.EKF.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">y0</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.EKF.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Main method during runtime. Pass the most recent measurement and
retrieve the estimated state.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="do_mpc.estimator.MHE">
<em class="property">class </em><code class="sig-prename descclassname">do_mpc.estimator.</code><code class="sig-name descname">MHE</code><span class="sig-paren">(</span><em class="sig-param">model</em>, <em class="sig-param">p_est_list=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#do_mpc.optimizer.Optimizer" title="do_mpc.optimizer.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.optimizer.Optimizer</span></code></a>, <a class="reference internal" href="#do_mpc.estimator.Estimator" title="do_mpc.estimator.Estimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.estimator.Estimator</span></code></a></p>
<p>THE MHE estimator extends the <a class="reference internal" href="#do_mpc.optimizer.Optimizer" title="do_mpc.optimizer.Optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.optimizer.Optimizer</span></code></a> base class
(which is also used for the MPC controller), as well as the <a class="reference internal" href="#do_mpc.estimator.Estimator" title="do_mpc.estimator.Estimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Estimator</span></code></a> base class.
Use this class to configure and run the MHE based on a previously configured <a class="reference internal" href="#do_mpc.model.Model" title="do_mpc.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model.Model</span></code></a> instance.</p>
<p>The class is initiated by passing a list of the <strong>parameters that should be estimated</strong>. This must be a subset (or all) of the parameters defined in
<a class="reference internal" href="#do_mpc.model.Model" title="do_mpc.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model.Model</span></code></a>. This allows to define parameters in the model that influence the model externally (e.g. weather predictions),
and those that are internal e.g. system parameters and can be estimated.
Passing an empty list (default) value, means that no parameters are estimated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Parameters are influencing the model equation at all timesteps but are constant over the entire horizon.
Parameters could also be introduced as states without dynamic but this would increase the total number of optimization variables.</p>
</div>
<p><strong>Configuration and setup:</strong></p>
<p>Configuring and setting up the MHE involves the following steps:</p>
<ol class="arabic simple">
<li><p>Use <a class="reference internal" href="#do_mpc.estimator.MHE.set_param" title="do_mpc.estimator.MHE.set_param"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.set_param()</span></code></a> to configure the <a class="reference internal" href="#do_mpc.estimator.MHE" title="do_mpc.estimator.MHE"><code class="xref py py-class docutils literal notranslate"><span class="pre">MHE</span></code></a>. See docstring for details.</p></li>
<li><p>Obtain the following variables from the class: <code class="docutils literal notranslate"><span class="pre">MHE._y_meas</span></code>, <code class="docutils literal notranslate"><span class="pre">MHE._y_calc</span></code>, <code class="docutils literal notranslate"><span class="pre">MHE._x_prev</span></code>, <code class="docutils literal notranslate"><span class="pre">MHE._x0</span></code>, <code class="docutils literal notranslate"><span class="pre">MHE._p_est_prev</span></code>, <code class="docutils literal notranslate"><span class="pre">MHE._p_est0</span></code></p></li>
<li><p>Set the objective of the control problem with <a class="reference internal" href="#do_mpc.estimator.MHE.set_objective" title="do_mpc.estimator.MHE.set_objective"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.set_objective()</span></code></a>.</p></li>
</ol>
<ol class="arabic simple" start="5">
<li><p>Set upper and lower bounds.</p></li>
<li><p>Optionally, set further (non-linear) constraints with <a class="reference internal" href="#do_mpc.optimizer.Optimizer.set_nl_cons" title="do_mpc.optimizer.Optimizer.set_nl_cons"><code class="xref py py-func docutils literal notranslate"><span class="pre">do_mpc.optimizer.Optimizer.set_nl_cons()</span></code></a>.</p></li>
<li><p>Use <a class="reference internal" href="#do_mpc.estimator.MHE.get_p_template" title="do_mpc.estimator.MHE.get_p_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.get_p_template()</span></code></a> and <a class="reference internal" href="#do_mpc.estimator.MHE.set_p_fun" title="do_mpc.estimator.MHE.set_p_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.set_p_fun()</span></code></a> to set the function for the parameters.</p></li>
<li><p>Finally, call <a class="reference internal" href="#do_mpc.estimator.MHE.setup" title="do_mpc.estimator.MHE.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.setup()</span></code></a>.</p></li>
</ol>
<p>During runtime use <a class="reference internal" href="#do_mpc.estimator.MHE.make_step" title="do_mpc.estimator.MHE.make_step"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.make_step()</span></code></a> with the most recent measurement to obtain the estimated states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="#do_mpc.model.Model" title="do_mpc.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model.Model</span></code></a>) – A configured and setup <a class="reference internal" href="#do_mpc.model.Model" title="do_mpc.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model.Model</span></code></a></p></li>
<li><p><strong>p_est_list</strong> (<em>list</em>) – List with names of parameters (<code class="docutils literal notranslate"><span class="pre">_p</span></code>) defined in <code class="docutils literal notranslate"><span class="pre">model</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="do_mpc.estimator.MHE.set_param">
<code class="sig-name descname">set_param</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE.set_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to set the parameters of the <a class="reference internal" href="#do_mpc.estimator.MHE" title="do_mpc.estimator.MHE"><code class="xref py py-class docutils literal notranslate"><span class="pre">MHE</span></code></a> class. Parameters must be passed as pairs of valid keywords and respective argument.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mhe</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="n">n_horizon</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible and convenient to pass a dictionary with multiple parameters simultaneously as shown in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">setup_mhe</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;n_horizon&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="s1">&#39;t_step&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">mhe</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="o">**</span><span class="n">setup_mhe</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">mhe.set_param()</span></code> can be called multiple times. Previously passed arguments are overwritten by successive calls.</p>
</div>
<p>The following parameters are available:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_horizon</strong> (<em>int</em>) – Prediction horizon of the optimal control problem. Parameter must be set by user.</p></li>
<li><p><strong>t_step</strong> (<em>float</em>) – Timestep of the mhe.</p></li>
<li><p><strong>meas_from_data</strong> (<em>bool</em>) – Default option to retrieve past measurements for the MHE optimization problem. The <a class="reference internal" href="#do_mpc.estimator.MHE.set_y_fun" title="do_mpc.estimator.MHE.set_y_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.set_y_fun()</span></code></a> is called during setup.</p></li>
<li><p><strong>state_discretization</strong> (<em>str</em>) – Choose the state discretization for continuous models. Currently only <code class="docutils literal notranslate"><span class="pre">'collocation'</span></code> is available. Defaults to <code class="docutils literal notranslate"><span class="pre">'collocation'</span></code>.</p></li>
<li><p><strong>collocation_type</strong> (<em>str</em>) – Choose the collocation type for continuous models with collocation as state discretization. Currently only <code class="docutils literal notranslate"><span class="pre">'radau'</span></code> is available. Defaults to <code class="docutils literal notranslate"><span class="pre">'radau'</span></code>.</p></li>
<li><p><strong>collocation_deg</strong> (<em>int</em>) – Choose the collocation degree for continuous models with collocation as state discretization. Defaults to <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p></li>
<li><p><strong>collocation_ni</strong> (<em>int</em>) – Choose the collocation ni for continuous models with collocation as state discretization. Defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
<li><p><strong>store_full_solution</strong> (<em>bool</em>) – Choose whether to store the full solution of the optimization problem. This is required for animating the predictions in post processing. However, it drastically increases the required storage. Defaults to False.</p></li>
<li><p><strong>store_lagr_multiplier</strong> (<em>bool</em>) – Choose whether to store the lagrange multipliers of the optimization problem. Increases the required storage. Defaults to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>store_solver_stats</strong> (<em>dict</em>) – Choose which solver statistics to store. Must be a list of valid statistics. Defaults to <code class="docutils literal notranslate"><span class="pre">['success','t_wall_S','t_wall_S']</span></code>.</p></li>
<li><p><strong>nlpsol_opts</strong> – <p>Dictionary with options for the CasADi solver call <code class="docutils literal notranslate"><span class="pre">nlpsol</span></code> with plugin <code class="docutils literal notranslate"><span class="pre">ipopt</span></code>. All options are listed <a class="reference external" href="http://casadi.sourceforge.net/api/internal/d4/d89/group__nlpsol.html">here</a>.</p>
</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We highly suggest to change the linear solver for IPOPT from <cite>mumps</cite> to <cite>MA27</cite>. In many cases this will drastically boost the speed of <strong>do mpc</strong>. Change the linear solver with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">optimizer</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="n">nlpsol_opts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ipopt.linear_solver&#39;</span><span class="p">:</span> <span class="s1">&#39;MA27&#39;</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To surpress the output of IPOPT, please use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">surpress_ipopt</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ipopt.print_level&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ipopt.sb&#39;</span><span class="p">:</span> <span class="s1">&#39;yes&#39;</span><span class="p">,</span> <span class="s1">&#39;print_time&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="n">nlpsol_opts</span> <span class="o">=</span> <span class="n">surpress_ipopt</span><span class="p">)</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="method">
<dt id="do_mpc.estimator.MHE.set_objective">
<code class="sig-name descname">set_objective</code><span class="sig-paren">(</span><em class="sig-param">stage_cost</em>, <em class="sig-param">arrival_cost</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE.set_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the objective function for the MHE problem. We suggest to formulate the MHE objective (<span class="math notranslate nohighlight">\(J\)</span>) such that:</p>
<div class="math notranslate nohighlight">
\[\begin{split}J= &amp; \underbrace{(x_0 - \tilde{x}_0)^T P_x (x_0 - \tilde{x}_0)}_{\text{arrival cost states}} +
\underbrace{(p_0 - \tilde{p}_0)^T P_p (p_0 - \tilde{p}_0)}_{\text{arrival cost params.}} \\
&amp; +\sum_{k=0}^{n-1} \underbrace{(h(x_k, u_k, p_k) - y_k)^T P_{y,k} (h(x_k, u_k, p_k) - y_k)}_{\text{stage cost}} \\\end{split}\]</div>
<p>Use the class attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mhe._y_meas</span></code> as <span class="math notranslate nohighlight">\(y_k\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mhe._y_calc</span></code> as <span class="math notranslate nohighlight">\(h(x_k, u_k, p_k)\)</span> (function is defined in <a class="reference internal" href="#do_mpc.model.Model" title="do_mpc.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model.Model</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mhe._x_prev</span></code> as <span class="math notranslate nohighlight">\(\tilde{x}_0\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mhe._x</span></code> as <span class="math notranslate nohighlight">\(x_0\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mhe._p_est_prev</span></code> as <span class="math notranslate nohighlight">\(\tilde{p}_0\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mhe._p_est</span></code> as <span class="math notranslate nohighlight">\(p_0\)</span></p></li>
</ul>
<p>To formulate the objective function and pass the stage cost and arrival cost independently.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The retrieved attributes are symbolic structures, which can be queried with the given variable names,
e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x1</span> <span class="o">=</span> <span class="n">mhe</span><span class="o">.</span><span class="n">_x</span><span class="p">[</span><span class="s1">&#39;state_1&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>For a vector of all states, use the <code class="docutils literal notranslate"><span class="pre">.cat</span></code> method as shown in the example below.</p>
</div>
<p><strong>Example:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get variables:</span>
<span class="n">y_meas</span> <span class="o">=</span> <span class="n">mhe</span><span class="o">.</span><span class="n">_y_meas</span>
<span class="n">y_calc</span> <span class="o">=</span> <span class="n">mhe</span><span class="o">.</span><span class="n">_y_calc</span>

<span class="n">dy</span> <span class="o">=</span> <span class="n">y_meas</span><span class="o">.</span><span class="n">cat</span><span class="o">-</span><span class="n">y_calc</span><span class="o">.</span><span class="n">cat</span>
<span class="n">stage_cost</span> <span class="o">=</span> <span class="n">dy</span><span class="o">.</span><span class="n">T</span><span class="nd">@np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">]))</span><span class="nd">@dy</span>

<span class="n">x_0</span> <span class="o">=</span> <span class="n">mhe</span><span class="o">.</span><span class="n">_x</span>
<span class="n">x_prev</span> <span class="o">=</span> <span class="n">mhe</span><span class="o">.</span><span class="n">_x_prev</span>
<span class="n">p_0</span> <span class="o">=</span> <span class="n">mhe</span><span class="o">.</span><span class="n">_p_est</span>
<span class="n">p_prev</span> <span class="o">=</span> <span class="n">mhe</span><span class="o">.</span><span class="n">_p_est_prev</span>

<span class="n">dx</span> <span class="o">=</span> <span class="n">x_0</span><span class="o">.</span><span class="n">cat</span> <span class="o">-</span> <span class="n">x_prev</span><span class="o">.</span><span class="n">cat</span>
<span class="n">dp</span> <span class="o">=</span> <span class="n">p_0</span><span class="o">.</span><span class="n">cat</span> <span class="o">-</span> <span class="n">p_prev</span><span class="o">.</span><span class="n">cat</span>

<span class="n">arrival_cost</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="o">*</span><span class="n">dx</span><span class="o">.</span><span class="n">T</span><span class="nd">@dx</span> <span class="o">+</span> <span class="mf">1e-4</span><span class="o">*</span><span class="n">dp</span><span class="o">.</span><span class="n">T</span><span class="nd">@dp</span>

<span class="n">mhe</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="n">stage_cost</span><span class="p">,</span> <span class="n">arrival_cost</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stage_cost</strong> (<em>CasADi expression</em>) – Stage cost that is added to the MHE objective at each age.</p></li>
<li><p><strong>arrival_cost</strong> (<em>CasADi expression</em>) – Arrival cost that is added to the MHE objective at the initial state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.estimator.MHE.get_p_template">
<code class="sig-name descname">get_p_template</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE.get_p_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the a numerical copy of the structure of the (not estimated) parameters.
Use this structure as the return of a user defined parameter function (<code class="docutils literal notranslate"><span class="pre">p_fun</span></code>)
that is called at each MHE step. Pass this function to the MHE by calling <a class="reference internal" href="#do_mpc.estimator.MHE.set_p_fun" title="do_mpc.estimator.MHE.set_p_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.set_p_fun()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The combination of <a class="reference internal" href="#do_mpc.estimator.MHE.get_p_template" title="do_mpc.estimator.MHE.get_p_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.get_p_template()</span></code></a> and <a class="reference internal" href="#do_mpc.estimator.MHE.set_p_fun" title="do_mpc.estimator.MHE.set_p_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.set_p_fun()</span></code></a> is
identical to the <a class="reference internal" href="#do_mpc.simulator.Simulator" title="do_mpc.simulator.Simulator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.simulator.Simulator</span></code></a> methods, if the MHE
is not estimating any parameters.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>p_template</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>struct_symSX</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.estimator.MHE.set_p_fun">
<code class="sig-name descname">set_p_fun</code><span class="sig-paren">(</span><em class="sig-param">p_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE.set_p_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameter function which is called at each MHE time step and returns the (not) estimated parameters.
The function must return a numerical CasADi structure, which can be retrieved with <a class="reference internal" href="#do_mpc.estimator.MHE.get_p_template" title="do_mpc.estimator.MHE.get_p_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.get_p_template()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p_fun</strong> (<em>function</em>) – Parameter function.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.estimator.MHE.get_y_template">
<code class="sig-name descname">get_y_template</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE.get_y_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the a numerical copy of the structure of the measurements for the set horizon.
Use this structure as the return of a user defined parameter function (<code class="docutils literal notranslate"><span class="pre">y_fun</span></code>)
that is called at each MHE step. Pass this function to the MHE by calling <a class="reference internal" href="#do_mpc.estimator.MHE.set_y_fun" title="do_mpc.estimator.MHE.set_y_fun"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.set_y_fun()</span></code></a>.</p>
<p>The structure carries a set of measurements for each time step of the horizon and can be accessed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y_template</span><span class="p">[</span><span class="s1">&#39;y_meas&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;meas_name&#39;</span><span class="p">]</span>
<span class="c1"># Slicing is possible, e.g.:</span>
<span class="n">y_template</span><span class="p">[</span><span class="s1">&#39;y_meas&#39;</span><span class="p">,</span> <span class="p">:,</span> <span class="s1">&#39;meas_name&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">k</span></code> runs from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">N_horizon-1</span></code> and <code class="docutils literal notranslate"><span class="pre">meas_name</span></code> refers to the user-defined names in <a class="reference internal" href="#do_mpc.model.Model" title="do_mpc.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.model.Model</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The structure is ordered, sucht that <code class="docutils literal notranslate"><span class="pre">k=0</span></code> is the “oldest measurement” and <code class="docutils literal notranslate"><span class="pre">k=N_horizon-1</span></code> is the newest measurement.</p>
</div>
<p>By default, the following measurement function is choosen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y_template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y_template</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">y_fun</span><span class="p">(</span><span class="n">t_now</span><span class="p">):</span>
    <span class="n">n_steps</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_horizon</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n_steps</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">y_template</span><span class="p">[</span><span class="s1">&#39;y_meas&#39;</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_horizon</span><span class="o">-</span><span class="n">n_steps</span><span class="p">):</span>
            <span class="n">y_template</span><span class="p">[</span><span class="s1">&#39;y_meas&#39;</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="o">-</span><span class="n">n_steps</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="kc">None</span>
    <span class="k">return</span> <span class="n">y_template</span>
</pre></div>
</div>
<p>Which simply reads the last results from the <code class="docutils literal notranslate"><span class="pre">MHE.data</span></code> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>y_template</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>struct_symSX</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.estimator.MHE.set_y_fun">
<code class="sig-name descname">set_y_fun</code><span class="sig-paren">(</span><em class="sig-param">y_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE.set_y_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the measurement function. The function must return a CasADi structure which can be obtained
from <a class="reference internal" href="#do_mpc.estimator.MHE.get_y_template" title="do_mpc.estimator.MHE.get_y_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.get_y_template()</span></code></a>. See the respective doc string for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>y_fun</strong> (<em>function</em>) – measurement function.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.estimator.MHE.set_initial_guess">
<code class="sig-name descname">set_initial_guess</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE.set_initial_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the current class attributes <code class="docutils literal notranslate"><span class="pre">_x0</span></code>, <code class="docutils literal notranslate"><span class="pre">_z0</span></code> and <code class="docutils literal notranslate"><span class="pre">_u0</span></code>, <code class="docutils literal notranslate"><span class="pre">_p_est0</span></code> to create an initial guess for the mhe.
The initial guess is simply the initial values for all instances of x, u and z, p_est. The method is automatically
evoked when calling the <a class="reference internal" href="#do_mpc.estimator.MHE.setup" title="do_mpc.estimator.MHE.setup"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.setup()</span></code></a> method.
However, if no initial values for x, u and z were supplied during setup, these default to zero.</p>
</dd></dl>

<dl class="method">
<dt id="do_mpc.estimator.MHE.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>The setup method finalizes the MHE creation. After this call, the py:func:<cite>do_mpc.optimizer.Optimizer.solve</cite> method is applicable.
The method wraps the following calls:</p>
<ul class="simple">
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.check_validity()</span></code></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE._setup_mpc_optim_problem()</span></code></p></li>
<li><p><a class="reference internal" href="#do_mpc.estimator.MHE.set_initial_guess" title="do_mpc.estimator.MHE.set_initial_guess"><code class="xref py py-func docutils literal notranslate"><span class="pre">MHE.set_initial_guess()</span></code></a></p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">do_mpc.optimizer.prepare_data()</span></code></p></li>
</ul>
<p>and sets the setup flag = True.</p>
</dd></dl>

<dl class="method">
<dt id="do_mpc.estimator.MHE.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">y0</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.estimator.MHE.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Main method of the class during runtime. This method is called at each timestep
and returns the current state estimate for the current measurement <code class="docutils literal notranslate"><span class="pre">y0</span></code>.</p>
<p>The method prepares the MHE by setting the current parameters, calls <a class="reference internal" href="#do_mpc.optimizer.Optimizer.solve" title="do_mpc.optimizer.Optimizer.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">do_mpc.optimizer.Optimizer.solve()</span></code></a>
and updates the <a class="reference internal" href="#do_mpc.data.Data" title="do_mpc.data.Data"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.data.Data</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>y0</strong> (<em>numpy.ndarray</em>) – Current measurement.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x0, estimated state of the system.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-do_mpc.simulator">
<span id="do-mpc-simulator"></span><h2>do_mpc.simulator<a class="headerlink" href="#module-do_mpc.simulator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="do_mpc.simulator.Simulator">
<em class="property">class </em><code class="sig-prename descclassname">do_mpc.simulator.</code><code class="sig-name descname">Simulator</code><span class="sig-paren">(</span><em class="sig-param">model</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class for simulating systems. Discrete-time and continuous systems can be considered.</p>
<dl class="method">
<dt id="do_mpc.simulator.Simulator.set_initial_state">
<code class="sig-name descname">set_initial_state</code><span class="sig-paren">(</span><em class="sig-param">x0</em>, <em class="sig-param">reset_history=False</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.set_initial_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the intial state of the simulator.
Optionally resets the history. The history is empty upon creation of the simulator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<em>numpy array</em>) – Initial state</p></li>
<li><p><strong>reset_history</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Resets the history of the simulator, defaults to False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.reset_history">
<code class="sig-name descname">reset_history</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.reset_history" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the history of the simulator</p>
</dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.check_validity">
<code class="sig-name descname">check_validity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.check_validity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the simulator after the parameters were set via set_param. The simulation time step is required in order to setup the simulator for continuous and discrete-time models.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>assertion</strong> – t_step must be set</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.set_param">
<code class="sig-name descname">set_param</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.set_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters for the simulator. Setting the simulation time step t_step is necessary for setting up the simulator via setup_simulator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>integration_tool</strong> (<em>string</em>) – Sets which integration tool is used, defaults to cvodes (only continuous)</p></li>
<li><p><strong>abstol</strong> (<em>float</em>) – gives the maximum allowed absolute tolerance for the integration, defaults to 1e-10 (only continuous)</p></li>
<li><p><strong>reltol</strong> – gives the maximum allowed relative tolerance for the integration, defaults to 1e-10 (only continuous)</p></li>
<li><p><strong>t_step</strong> (<em>float</em>) – Sets the time step for the simulation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.get_tvp_template">
<code class="sig-name descname">get_tvp_template</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.get_tvp_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the a numerical copy of the structure of the time-varying parameters for the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>numerical CasADi structure</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>struct_SX</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.set_tvp_fun">
<code class="sig-name descname">set_tvp_fun</code><span class="sig-paren">(</span><em class="sig-param">tvp_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.set_tvp_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to set the function which gives the values of the time-varying parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tvp_fun</strong> (<em>python function</em>) – [ParamDescription], defaults to [DefaultParamVal]</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>[</strong><strong>ErrorType</strong><strong>]</strong> – the output of tvp_fun must have the right structure</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.get_p_template">
<code class="sig-name descname">get_p_template</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.get_p_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the a numerical copy of the structure of the parameters for the simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>numerical CasADi structure</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>struct_SX</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.set_p_fun">
<code class="sig-name descname">set_p_fun</code><span class="sig-paren">(</span><em class="sig-param">p_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.set_p_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to set the function which gives the values of the parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p_fun</strong> (<em>python function</em>) – A function which gives the values of the parameters</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>assert</strong> – p must have the right structure</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.simulate">
<code class="sig-name descname">simulate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the core function of the simulator class. Numerical values for sim_x_num and sim_p_num need to be provided beforehand in order to simulate the system for one time step:</p>
<ul class="simple">
<li><p>states (sim_x_num[‘_x’])</p></li>
<li><p>algebraic states (sim_x_num[‘_z’])</p></li>
<li><p>inputs (sim_p_num[‘_u’])</p></li>
<li><p>parameter (sim_p_num[‘_p’])</p></li>
<li><p>time-varying parameters (sim_p_num[‘_tvp’])</p></li>
</ul>
<p>The function returns the new state of the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>x_new</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.simulator.Simulator.make_step">
<code class="sig-name descname">make_step</code><span class="sig-paren">(</span><em class="sig-param">u0</em>, <em class="sig-param">x0=None</em>, <em class="sig-param">z0=None</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.simulator.Simulator.make_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Main method of the simulator class during control runtime. This method is called at each timestep
and returns the next state for the current control input <code class="docutils literal notranslate"><span class="pre">u0</span></code>.
The initial state <code class="docutils literal notranslate"><span class="pre">x0</span></code> is stored as a class attribute but can optionally be supplied.
The algebraic states <code class="docutils literal notranslate"><span class="pre">z0</span></code> can also be supplied, if they are defined in the model but are only used as an intial guess.</p>
<p>The method prepares the simulator by setting the current parameters, calls <code class="xref py py-func docutils literal notranslate"><span class="pre">simulator.simulate()</span></code>
and updates the <a class="reference internal" href="#module-do_mpc.data" title="do_mpc.data"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.data</span></code></a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u0</strong> (<em>numpy.ndarray</em>) – Current input to the system.</p></li>
<li><p><strong>x0</strong> (<em>numpy.ndarray</em><em> (</em><em>optional</em><em>)</em>) – Current state of the system.</p></li>
<li><p><strong>z0</strong> (<em>numpy.ndarray</em><em> (</em><em>optional</em><em>)</em>) – Initial guess for current algebraic states</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>x_nsext</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-do_mpc.data">
<span id="do-mpc-data"></span><h2>do_mpc.data<a class="headerlink" href="#module-do_mpc.data" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="do_mpc.data.Data">
<em class="property">class </em><code class="sig-prename descclassname">do_mpc.data.</code><code class="sig-name descname">Data</code><span class="sig-paren">(</span><em class="sig-param">model</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.data.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="do_mpc.data.Data.init_storage">
<code class="sig-name descname">init_storage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.data.Data.init_storage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="do_mpc.data.Data.set_meta">
<code class="sig-name descname">set_meta</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.data.Data.set_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Set meta data for the current instance of the data object.</p>
</dd></dl>

<dl class="method">
<dt id="do_mpc.data.Data.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.data.Data.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update value(s) of the data structure with key word arguments.
These key word arguments must exist in the data fields of the data objective.
See self.data_fields for a complete list of data fields.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s1">&#39;_x&#39;</span><span class="p">:</span> <span class="n">_x</span><span class="p">,</span> <span class="s1">&#39;_u&#39;</span><span class="p">:</span> <span class="n">_u</span><span class="p">)</span>

<span class="ow">or</span><span class="p">:</span>
<span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s1">&#39;_x&#39;</span><span class="p">:</span> <span class="n">_x</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s1">&#39;_u&#39;</span><span class="p">:</span> <span class="n">_u</span><span class="p">)</span>

<span class="n">Alternatively</span><span class="p">:</span>
<span class="n">data_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_x&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
    <span class="s1">&#39;_u&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>

<span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">data_dict</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – <p>Arbitrary number of key word arguments for data fields that should be updated.</p>
</p>
</dd>
</dl>
<p>:type casadi.DM or numpy.ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>assertion</strong> – Keyword must be in existing data_fields.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="do_mpc.data.Data.export">
<code class="sig-name descname">export</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.data.Data.export" title="Permalink to this definition">¶</a></dt>
<dd><p>The export method returns a dictionary of the stored data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Dictionary of the currently stored data.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="do_mpc.data.save_results">
<code class="sig-prename descclassname">do_mpc.data.</code><code class="sig-name descname">save_results</code><span class="sig-paren">(</span><em class="sig-param">save_list</em>, <em class="sig-param">result_name='results'</em>, <em class="sig-param">result_path='./results/'</em>, <em class="sig-param">overwrite=False</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.data.save_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Exports the data objects from the <strong>do mpc</strong> modules in <code class="docutils literal notranslate"><span class="pre">save_list</span></code> as a pickled file. Supply any, all or a selection of (as a list):</p>
<ul class="simple">
<li><p><a class="reference internal" href="#module-do_mpc.optimizer" title="do_mpc.optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.optimizer</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-do_mpc.simulator" title="do_mpc.simulator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.simulator</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-do_mpc.estimator" title="do_mpc.estimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.estimator</span></code></a></p></li>
</ul>
<p>These objects can be used in post-processing to create graphics with the <code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.graphics_backend</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>save_list</strong> (<em>list</em>) – List of the objects to be stored.</p></li>
<li><p><strong>result_name</strong> (<em>string</em><em>, </em><em>optional</em>) – Name of the result file, defaults to ‘result’.</p></li>
<li><p><strong>result_path</strong> (<em>string</em><em>, </em><em>optional</em>) – Result path, defaults to ‘./results/’.</p></li>
<li><p><strong>overwrite</strong> (<em>bool</em><em>, </em><em>optional</em>) – Option to overwrite existing results, defaults to False. Index will be appended if file already exists.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>assertion</strong> – save_list must be a list.</p></li>
<li><p><strong>assertion</strong> – result_name must be a string.</p></li>
<li><p><strong>assertion</strong> – results_path must be a string.</p></li>
<li><p><strong>assertion</strong> – overwrite must be boolean.</p></li>
<li><p><strong>Exception</strong> – save_list contains object which is neither do_mpc simulator, optimizizer nor estimator.</p></li>
</ul>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="do_mpc.data.load_results">
<code class="sig-prename descclassname">do_mpc.data.</code><code class="sig-name descname">load_results</code><span class="sig-paren">(</span><em class="sig-param">file_name</em><span class="sig-paren">)</span><a class="headerlink" href="#do_mpc.data.load_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple wrapper to open and unpickle a file.
If used for <strong>do mpc</strong> results, this will return a dictionary with the stored <strong>do mpc</strong> modules:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#module-do_mpc.optimizer" title="do_mpc.optimizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.optimizer</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-do_mpc.simulator" title="do_mpc.simulator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.simulator</span></code></a></p></li>
<li><p><a class="reference internal" href="#module-do_mpc.estimator" title="do_mpc.estimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">do_mpc.estimator</span></code></a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file_name</strong> (<em>str</em>) – File name (including path) for the file to be opened and unpickled.</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="modules.html" class="btn btn-neutral float-left" title="API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Lucia

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>